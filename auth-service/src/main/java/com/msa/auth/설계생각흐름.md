## 1단계: "핵심 명사"와 "규칙" 찾기 (Domain)
가장 먼저 기술(Spring, DB)을 잊고 **"비즈니스 자체"**만 생각하세요.

생각의 흐름: "회원가입 시스템이니까 가장 중요한 명사는 **'사용자(User)'**네? 사용자는 이메일, 비번, 닉네임이 필요하고... 아! 이메일은 형식이 맞아야 하고 비번은 암호화되어야 한다는 규칙이 있지?"

결과: domain 패키지에 User 엔티티와 UserRole Enum을 먼저 설계합니다. 외부 도움 없이 스스로를 검증하는 로직(validate)을 이때 넣습니다.

## 2단계: "무엇을 할 것인가?" 정의 (In-Port)
이제 외부에서 우리 시스템에 어떤 요청을 할지 정의합니다.

본체인 Application에게 말을 거는 것이 In-Port

생각의 흐름: "클라이언트는 '회원가입'과 '로그인'을 하고 싶어 하겠지? 그럼 이게 이 시스템의 **입구(UseCase)**가 되겠네?"

결과: application.port.in 패키지에 RegisterUseCase, LoginUseCase 인터페이스를 만듭니다.

## 3단계: "외부의 도움이 필요한가?" 정의 (Out-Port)
비즈니스 로직을 수행하다가 외부(DB, 외부 API)의 힘이 필요한 순간을 정의합니다.

본체인 Application이 말을 거는 거면 Out-Port

생각의 흐름: "회원가입을 하려면 DB에 저장해야 하고, 기존 유저가 있는지 찾아봐야 하네? 근데 난 DB가 뭔지(MySQL? Oracle?) 지금 정하고 싶지 않아. 그냥 **'저장하는 기능'**과 **'찾는 기능'**이 필요하다고 약속만 하자."

결과: application.port.out 패키지에 SaveUserPort, LoadUserPort 인터페이스를 만듭니다.

## 4단계: "로직 조립하기" (Service)
이제 위에서 만든 부품들을 한곳에 모아 실제 흐름을 짭니다.

생각의 흐름: "AuthService를 만들자. 얘는 아까 만든 RegisterUseCase를 구현하고, DB가 필요하니 Out-Port들을 가져다 써야지. 중복 체크하고 -> 암호화하고 -> User 객체 만들어서 -> 저장 포트로 보낸다!"

결과: application.service 패키지에 AuthService를 구현합니다.

## 5단계: "껍데기 갈아 끼우기" (Adapter)
마지막으로 실제 기술들을 연결합니다.

생각의 흐름: "자, 이제 웹 브라우저 요청을 받을 컨트롤러가 필요해(in.web). 그리고 진짜 DB랑 통신할 레포지토리와 어댑터가 필요하겠지?(out.persistence)"

결과: UserRepository를 만들고, PersistenceAdapter에서 포트를 구현(implements)하여 실제 DB 로직을 완성합니다.

## 💡 설계의 마무리: "의존성 체크"
구현을 시작하기 전 딱 하나만 확인하세요.

"내 도메인(User)과 서비스(AuthService) 코드가 외부 기술(JPA, Web) 없이도 돌아가는가?"

만약 그렇다면 설계가 완벽한 것입니다!

## 🚀 스스로 작성할 때의 순서 제안 (Best Practice)
Domain: User 클래스를 만든다. (이메일 검증 로직 포함)

Port: 필요한 인터페이스들(UseCase, Port)을 쭉 만든다.

Service: AuthService를 만들고 로직을 짠다. (이때 빨간 줄이 뜨면 Dto들을 만든다.)

Adapter: 마지막으로 Controller와 Repository를 만들어 연결한다.