# 🏛️ 헥사고날 아키텍처(Hexagonal Architecture) 완벽 가이드

## 1. 철학: "핵심 로직을 외부 환경으로부터 보호하라" (비유: 게임기)
헥사고날 아키텍처의 목표는 비즈니스 로직을 DB, 웹, 외부 API 등 기술적 환경으로부터 완전히 분리하는 것입니다.

* **게임기 본체 (Core: Domain/Application)**:
    * 게임의 승리 규칙, 캐릭터의 레벨업 조건 등이 들어있는 핵심 장치입니다.
    * 모니터가 삼성인지 LG인지, 조이스틱이 소니인지 닌텐도인지 몰라도 게임은 똑같이 동작해야 합니다.
* **주변 기기 (Adapters)**:
    * 본체에 연결되는 조이스틱(Web), 모니터(DB), 스피커(External API) 등입니다.
    * 본체에 뚫려 있는 **규격화된 구멍(Port)**에 꽂히기만 하면 언제든 갈아 끼울 수 있습니다.

---

## 2. 패키지 구조: 성(Castle)과 외부 마을
우리의 코드는 크게 **성 내부(Application)**와 **성 외부(Adapter)**로 나뉩니다.

```text
com.company.project
 ├── domain (가장 깊은 성전: 핵심 규칙 및 엔티티)
 └── application (성 내부: 비즈니스 흐름 조절)
      ├── port
      │    ├── in  (입구: UseCase - 외부에서 들어오는 초인종)
      │    └── out (출구: Port - 내부에서 외부로 나가는 콘센트)
      └── service (관리자: AuthService - 모든 동작을 조립)
 └── adapter (성 외부: 실제 기술 구현체)
      ├── in  (Web Controller: 초인종을 누르는 사람)
      └── out (Persistence Adapter: 콘센트에 꽂히는 실제 가전)
```

---

## 3. 포트(Port)의 종류: 인(In)과 아웃(Out)
누가 주도권을 쥐고 있느냐에 따라 나뉩니다.

| 구분 | 위치 | 역할 (비유) | 주체 |
| :--- | :--- | :--- | :--- |
| **In-Port (UseCase)** | `application.port.in` | 성 안으로 들어오는 **초인종** | 외부(사용자/Web)가 호출 |
| **Out-Port (Port)** | `application.port.out` | 성 밖으로 나가는 **콘센트 구멍** | 내부(Service)가 호출 |

* **AuthService(관리자)**는 초인종(`In-Port`)이 울리면 동작을 시작하고, 데이터를 저장할 때는 콘센트(`Out-Port`)에 데이터를 던집니다.

---

## 4. 의존성 역전(DIP)과 방향의 비밀
"모든 의존성(화살표)은 안쪽(Application)으로 향한다"는 원칙의 핵심입니다.

* **Service (안쪽)**: 자기 방(패키지)에 있는 `Port`(인터페이스)만 봅니다. 밖에서 JPA를 쓰는지 파일 저장을 하는지 관심이 없습니다. (의존성이 기술로부터 자유로움)
* **Adapter (바깥쪽)**: 일을 하려면 반드시 안쪽 패키지에 정의된 `Port` 규격을 가져와서 구현(`implements`)해야 합니다.
* **결과**: 바깥쪽(`Adapter`)이 안쪽(`Application`)의 규칙을 따르기 위해 안을 바라보게 되어, 의존성의 화살표가 밖에서 안으로 향하게 됩니다.

---

## 5. 실전 구현 예제: 회원가입 (Flow)

### [Step 1] Domain
핵심 규칙 (User 엔티티)
```java
public class User {
    private String email;
    private String password;
    
    // 비즈니스 규칙: "이메일은 @를 포함해야 한다"
    public void validateEmail() {
        if(!email.contains("@")) throw new IllegalArgumentException("올바르지 않은 이메일 형식입니다.");
    }
}
```

### [Step 2] In-Port
초인종 설계 (RegisterUseCase) 외부에서 성 내부로 들어오기 위한 인터페이스입니다.
```java
public interface RegisterUseCase {
    void registerUser(SignupRequestDto command);
}
```
### [Step 3] Out-Port
콘센트 설계 (SaveUserPort) 성 내부에서 외부 기술을 빌리기 위한 인터페이스입니다.

```java
public interface SaveUserPort {
    void saveUser(User user);
}
```

### [Step 4] Service
성 관리자 (AuthService) 초인종 응답을 받고, 도메인 규칙을 실행하며, 콘센트를 통해 결과를 보냅니다.

```java
@Service
@RequiredArgsConstructor
public class AuthService implements RegisterUseCase { // 초인종 응답(In-Port 구현)
    private final SaveUserPort saveUserPort; // 콘센트 사용(Out-Port 의존)

    @Override
    public void registerUser(SignupRequestDto command) {
        // 1. 도메인 객체 생성
        User user = new User(command.getEmail(), command.getPassword());
        
        // 2. 비즈니스 규칙 검증 (안쪽 로직 실행)
        user.validateEmail(); 
        
        // 3. 외부 저장소로 전달 (콘센트에 던지기)
        saveUserPort.saveUser(user); 
    }
}
```

### [Step 5] Out-Adapter
실제 가전 연결 (PersistenceAdapter) 성 밖에서 실제 DB 기술(JPA 등)을 사용해 콘센트 기능을 구현합니다.

```java
@Component
@RequiredArgsConstructor
public class UserPersistenceAdapter implements SaveUserPort { // 안쪽 규격(Port) 구현
    private final UserRepository userRepository; // 실제 JPA 기술 사용

    @Override
    public void saveUser(User user) {
        // 실제 DB 저장 로직 실행
        userRepository.save(user); 
    }
}
```
---

## 💡 한 줄 요약
"성 내부(Application)는 무엇을 할지(What)만 결정하고, 성 외부(Adapter)가 그것을 어떻게 기술적으로 처리할지(How) 고민하게 하라."
